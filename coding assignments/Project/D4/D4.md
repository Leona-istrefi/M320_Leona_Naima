## Delegation 
#### Where is Delagation used? 
<ls> 
<ul>LandVehicle.java </ul>
<ul>LandVehicleBehavior.java </ul>
<ul>Main.java </ul>
</ls>

#### How is it used? 

##### LandVehicle.java
<p >This class represents a generic land vehicle and delegates certain behaviors to the LandVehicleBehavior class. </p>


public class LandVehicle extends Vehicle {
    private LandVehicleBehavior behavior; // Delegated behavior

    public LandVehicle(/* parameters */) {
        // Initialize the behavior
        this.behavior = new LandVehicleBehavior();
    }

    // Delegating method to check highway approval
    public boolean getHighWayApproval() {
        return behavior.getHighWayApproval();
    }

    public void setHighWayApproval(boolean approval) {
        behavior.setHighWayApproval(approval);
    }
}


##### LandVehicleBehavior.java 
<p>  This class contains the logic for behaviors related to land vehicles, such as checking for highway approvals.</p>


public class LandVehicleBehavior {
    private boolean highWayApproval;

    public boolean getHighWayApproval() {
        return highWayApproval;
    }

    public void setHighWayApproval(boolean approval) {
        this.highWayApproval = approval;
    }

    // Additional behaviors related to land vehicles can be added here
}


##### Example of subClass (car) 
<p> Here’s how a specific vehicle, like Car, extends LandVehicle but doesn’t need to implement highway checks itself. It relies on the delegated behavior.</p>

public class Car extends LandVehicle {
    public Car(/* parameters */) {
        super(/* parameters */);
    }

    // Additional methods specific to Car
}

##### Main Class
<p> The Main class orchestrates the overall application flow but relies on the VehicleRentalManager to handle vehicle management. This is another form of delegation. </p>

private static void rentVehicle() {
    // ... previous code ...

    Vehicle selectedVehicle = availableVehicles.get(vehicleIndex);

    try {
        if (customer.getAge() < selectedVehicle.getAgeApproval()) {
            throw new minorAgeException("Access Denied. You are not old enough to rent this vehicle.");
        }

        // Here, the Main class checks if the vehicle has highway approval
        if (selectedVehicle instanceof LandVehicle) {
            LandVehicle landVehicle = (LandVehicle) selectedVehicle;
            if (!landVehicle.getHighWayApproval()) {
                System.out.println("This vehicle is not approved for highway use.");
                return;
            }
        }

        // ... further rental logic ...
    }
}


## Generics

### How Generics Work

#### Type Parameters:
<p> Generics use type parameters, which are defined using angle brackets (<>). For example, <T> defines a generic type T.</p>

#### Type Safety: 
<p> Generics provide compile-time type checking, which helps avoid ClassCastException at runtime. This means that you can specify what type of object a class or method can work with.</p>

#### Reusability: 
<p> By using generics, you can write a single class or method that can operate on different types of objects without needing to overload them.</p>

#### Bound Type Parameters: 
<p> You can restrict the types that can be passed as type parameters using bounds. For example, <T extends Vehicle> means that T must be a subclass of Vehicle.</p>

### Contract Class with Generics

public class Contract<T extends Vehicle> {
    private Person customer;
    private T vehicle; // Generic type T
    private LocalDate startDate;
    private LocalDate endDate;
    private String terms;

    public Contract(Person customer, T vehicle, LocalDate startDate, LocalDate endDate, String terms) {
        this.customer = customer;
        this.vehicle = vehicle;
        this.startDate = startDate;
        this.endDate = endDate;
        this.terms = terms;
    }

    public T getVehicle() {
        return vehicle; // Returns the vehicle of type T
    }

    // Other methods...
}

### Explanation of Usage

#### Generic Type Parameter: 
<p>The Contract class defines a type parameter T, which extends Vehicle. This means that T can be any subclass of Vehicle, allowing the Contract class to handle various types of vehicles (e.g., Car, Truck, Airplane).</p>

#### Type-Safe Vehicle Handling:
<p>By using a generic type for the vehicle field, the Contract class can store a vehicle of any type that extends Vehicle. This ensures that only valid vehicle types can be used, enhancing type safety.</p>

#### Method Returns:
<p>The method getVehicle() returns a vehicle of type T, allowing the caller to know exactly what type of vehicle they are dealing with, without needing to cast it.</p>
